==> src/renderer/renderer.js <==
/* Preload guard */
if (!('api' in window)) {
  alert('Failed to load preload bridge. Buttons will not work.\nCheck main.js preload path.');
}

/* global api */
const state = {
  db: null,
  view: { type: 'today', projectId: null },
  showCompleted: false,
  security: { encryptionEnabled: false, useBiometrics: false, biometricsAvailable: false },
  unlocked: false,
};

const el = (sel) => document.querySelector(sel);
const els = (sel) => Array.from(document.querySelectorAll(sel));

/* ---- Titlebar window controls ---- */
document.addEventListener('DOMContentLoaded', () => {
  const closeBtn = document.querySelector('.tb-close');
  const minBtn = document.querySelector('.tb-min');
  const maxBtn = document.querySelector('.tb-max');
  const bar = document.getElementById('titlebar');

  closeBtn?.addEventListener('click', () => api.windowControls.close());
  minBtn?.addEventListener('click', () => api.windowControls.minimize());
  maxBtn?.addEventListener('click', () => api.windowControls.toggleMaximize());
  bar?.addEventListener('dblclick', () => api.windowControls.toggleMaximize());
});

document.addEventListener('DOMContentLoaded', init);

async function init() {
  state.security = await api.securityGetConfig();

  if (state.security.encryptionEnabled) {
    await unlockFlow();
  } else {
    // Offer to enable encryption on first run
    await maybeEnableEncryptionFlow();
  }

  await loadAndRender();
  bindNav();
  bindInputs();
}

/* ---------- Security flows ---------- */
async function unlockFlow() {
  console.log('Unlock flow started, security config:', state.security);
  
  // If biometrics are enabled, try them first without showing passcode modal
  if (state.security.useBiometrics && state.security.biometricsAvailable) {
    try {
      console.log('Attempting biometric unlock...');
      const res = await api.securityUnlock(null); // Pass null to try biometrics first
      console.log('Biometric unlock result:', res);
      if (res && res.ok === false && res.code === 'NO_BIO_KEY') {
        const choice = confirm(
          'Touch ID succeeded, but no decryption key was found in your Keychain.\n\nThis usually happens if encryption was enabled without saving the key to Keychain, or the item was deleted.\n\nClick OK to use your passcode this time (and reseed the Keychain), or Cancel to abort.'
        );
        if (!choice) return; // user canceled
        // fall through to passcode modal (do not auto-open without consent)
      } else if (res && res.ok === false && res.code === 'NEED_PASSCODE') {
        // Biometric path didn’t complete; proceed to passcode modal.
      } else if (res && res.ok === false) {
        alert(`Unlock failed: ${res.code || 'Unknown error'}`);
        return; // abort
      }
      if (res?.ok) {
        console.log('Biometric unlock successful');
        state.unlocked = true;
        return; // Exit here, don't show passcode modal
      }
    } catch (e) {
      console.log('Biometrics failed, falling back to passcode:', e.message);
      // Continue to passcode modal only if biometrics actually failed
    }
  }
  
  // Only show passcode modal if biometrics are not enabled or user agreed to use passcode after a biometric issue.
  console.log('Showing passcode modal...');
  const pass = await promptModal({
    title: 'Unlock',
    bodyHTML: `
      <p>Enter your passcode to decrypt your tasks.</p>
      <input id="pass" type="password" placeholder="Passcode" autofocus />
    `,
    okText: 'Unlock',
  });
  if (!pass) return; // user cancelled — they'll see empty UI; can refresh to retry

  try {
    const res = await api.securityUnlock(pass);
    if (res?.ok) {
      console.log('Passcode unlock successful');
      state.unlocked = true;
    }
  } catch (e) {
    console.error('Passcode unlock failed:', e);
    alert('Unlock failed. Try again.');
    return unlockFlow();
  }
}

async function maybeEnableEncryptionFlow() {
  const yes = confirm(
    'Encrypt your data at rest? (Recommended)\nYou can enable this later in code, but doing it now is best.',
  );
  if (!yes) return;
  const { value: pass, canceled } = await promptModalWithReturn({
    title: 'Enable Encryption',
    bodyHTML: `
      <p>Create a passcode (min 4 chars). Don’t forget it — you’ll need it to unlock and restore backups.</p>
      <input id="pass" type="password" placeholder="Passcode" autofocus />
      <label><input id="bio" type="checkbox" /> Use Touch ID on this Mac</label>
    `,
    okText: 'Enable',
  });
  if (canceled) return;
  const useBio = el('#bio')?.checked || false;
  const p = String(pass || '').trim();
  if (p.length < 4) {
    alert('Passcode must be at least 4 characters.');
    return maybeEnableEncryptionFlow();
  }
  await api.securityEnable(p, useBio);
  state.unlocked = true;
}

/* ---------- Modal helpers ---------- */
function promptModal({ title, bodyHTML, okText = 'OK', cancelText = 'Cancel' }) {
  return new Promise((resolve) => {
    const modal = el('#modal');
    el('#modal-title').textContent = title;
    el('#modal-body').innerHTML = bodyHTML;
    modal.classList.remove('hidden');

    const ok = el('#modal-ok');
    const cancel = el('#modal-cancel');
    ok.textContent = okText;
    cancel.textContent = cancelText;

    const finish = (val) => {
      modal.classList.add('hidden');
      resolve(val);
    };

    // Handle Enter key submission
    const handleKeyPress = (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        ok.click();
      }
    };

    // Add keypress listeners to all input fields
    const inputs = modal.querySelectorAll('input, textarea, select');
    inputs.forEach(input => {
      input.addEventListener('keypress', handleKeyPress);
    });

    // Focus the first input with autofocus or the first input available
    setTimeout(() => {
      const autofocusInput = modal.querySelector('[autofocus]');
      const firstInput = modal.querySelector('input, textarea, select');
      if (autofocusInput) {
        autofocusInput.focus();
      } else if (firstInput) {
        firstInput.focus();
      }
    }, 100);

    ok.onclick = () => {
      // Check for different input types
      const projectName = el('#project-name')?.value;
      const editTitle = el('#edit-title')?.value;
      const pass = el('#pass')?.value;
      
      // Return the appropriate value based on what's in the modal
      if (projectName !== undefined) finish(projectName);
      else if (editTitle !== undefined) finish(true); // For edit modals, just return true
      else if (pass !== undefined) finish(pass);
      else finish(true); // Default fallback
    };
    cancel.onclick = () => finish(null);

    // Clean up event listeners when modal is closed
    const cleanup = () => {
      inputs.forEach(input => {
        input.removeEventListener('keypress', handleKeyPress);
      });
    };
    
    // Store cleanup function on modal element for later use
    modal._cleanup = cleanup;
  });
}
function promptModalWithReturn(opts) {
  return new Promise((resolve) => {
    const modal = el('#modal');
    el('#modal-title').textContent = opts.title;
    el('#modal-body').innerHTML = opts.bodyHTML;
    modal.classList.remove('hidden');

    const ok = el('#modal-ok');
    const cancel = el('#modal-cancel');
    ok.textContent = opts.okText || 'OK';
    cancel.textContent = opts.cancelText || 'Cancel';

    const finish = (value, canceled = false) => {
      modal.classList.add('hidden');
      resolve({ value, canceled });
    };
    ok.onclick = () => finish(el('#pass')?.value ?? '');
    cancel.onclick = () => finish('', true);
  });
}

/* ---------- Binding ---------- */
function bindNav() {
  
  els('.nav-item').forEach((b) => {
    b.addEventListener('click', () => {
      const v = b.dataset.view;
      if (v === 'today' || v === 'week' || v === 'all') {
        state.view = { type: v, projectId: null };
        renderAll();
      }
    });
  });

  el('#add-project-btn').addEventListener('click', async () => {
    const name = await promptModal({
      title: 'New Project',
      bodyHTML: `
        <div class="form-group">
          <label for="project-name">Project Name</label>
          <input id="project-name" type="text" placeholder="Enter project name" autofocus />
        </div>
      `,
      okText: 'Create',
    });
    
    if (!name) return; // user cancelled
    
    const trimmed = name.trim();
    if (!trimmed) {
      alert('Project name cannot be empty');
      return;
    }
    
    try {
      const created = await api.addProject(trimmed);
      await loadAndRender();
      if (created?.id) {
        state.view = { type: 'project', projectId: created.id };
        renderAll();
      }
    } catch (err) {
      console.error('addProject failed:', err);
      alert(`Failed to add project: ${err?.message || err}`);
    }
  });

  el('#export-btn').addEventListener('click', async () => {
    const res = await api.exportBackup();
    if (res?.ok) alert(`Backup saved to:\n${res.filePath}`);
  });

  el('#import-btn').addEventListener('click', async () => {
    const res = await api.importBackup();
    if (res?.ok) {
      await loadAndRender();
      alert('Backup restored.');
    }
  });

  el('#view-completed-btn').addEventListener('click', () => {
    state.showCompleted = !state.showCompleted;
    el('#toggle-completed').checked = state.showCompleted;
    renderAll();
  });
  
}

function bindInputs() {
  // Handle Enter key submission for new task
  el('#new-title').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      onAddTask();
    }
  });
  
  // Handle option button clicks
  bindOptionButtons();
}

function bindOptionButtons() {
  // Due date button
  el('#due-date-btn').addEventListener('click', () => {
    toggleOptionInput('due-date-input', 'due-date-btn');
  });
  
  // Priority button
  el('#priority-btn').addEventListener('click', () => {
    toggleOptionInput('priority-input', 'priority-btn');
  });
  
  // Tags button
  el('#tags-btn').addEventListener('click', () => {
    toggleOptionInput('tags-input', 'tags-btn');
  });
  
  // Project button
  el('#project-btn').addEventListener('click', () => {
    toggleOptionInput('project-input', 'project-btn');
  });
  
  // Close option inputs when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.option-group')) {
      closeAllOptionInputs();
    }
  });
}

function toggleOptionInput(inputId, buttonId) {
  const input = el(`#${inputId}`);
  const button = el(`#${buttonId}`);
  
  // Close all other inputs first
  closeAllOptionInputs();
  
  // Toggle this input
  if (input.style.display === 'none') {
    input.style.display = 'block';
    button.classList.add('active');
    
    // Focus the first input in the expanded section
    const firstInput = input.querySelector('input, select');
    if (firstInput) {
      setTimeout(() => firstInput.focus(), 100);
    }
  } else {
    input.style.display = 'none';
    button.classList.remove('active');
  }
}

function closeAllOptionInputs() {
  const inputs = els('.option-input');
  const buttons = els('.option-btn');
  
  inputs.forEach(input => {
    input.style.display = 'none';
  });
  
  buttons.forEach(button => {
    button.classList.remove('active');
  });
}

/* ---------- Data ---------- */
async function loadAndRender() {
  state.db = await api.loadDB();
  renderAll();
}

/* ---------- Rendering ---------- */
function renderAll() {
  renderProjects();
  renderNewTaskProjectSelect();
  renderHeaderTitle();
  renderTasks();
  syncCompletedToggle();
}

function syncCompletedToggle() {
  // Only sync with the bottom toggle since we removed the top one
  // The bottom toggle is handled by the view-completed-btn click handler
  // No need to sync anything here anymore
}

function renderProjects() {
  const ul = el('#project-list');
  ul.innerHTML = '';
  const projects = [...(state.db?.projects || [])];
  
  projects.forEach((p) => {
    const li = document.createElement('li');

    const btn = document.createElement('button');
    btn.className = 'project-item';
    if (p.id === 'inbox') {
      btn.className += ' inbox-project';
      btn.title = 'Default project (cannot be deleted)';
    }
    btn.textContent = p.name;
    btn.addEventListener('click', () => {
      state.view = { type: 'project', projectId: p.id };
      renderAll();
    });

    const kebab = document.createElement('button');
    kebab.textContent = '⋯';
    kebab.title = 'Project menu';
    kebab.addEventListener('click', async (e) => {
      e.stopPropagation();
      const choice = await projectMenu(p.id === 'inbox');
      if (choice === 'rename') {
        const name = await promptModal({
          title: 'Rename Project',
          bodyHTML: `
            <div class="form-group">
              <label for="project-name">New Name</label>
              <input id="project-name" type="text" value="${p.name}" autofocus />
            </div>
          `,
          okText: 'Rename',
        });
        if (name && name.trim()) {
          const trimmed = name.trim();
          if (trimmed === p.name) return; // No change
          if (!trimmed) {
            alert('Project name cannot be empty');
            return;
          }
          await api.renameProject(p.id, trimmed);
          await loadAndRender();
        }
      } else if (choice === 'delete') {
        if (p.id === 'inbox') return; // This should never happen now, but safety check
        const ok = confirm(`Delete "${p.name}"? Tasks will move to Inbox.`);
        if (ok) {
          await api.deleteProject(p.id);
          await loadAndRender();
        }
      }
    });

    li.appendChild(btn);
    li.appendChild(kebab);
    ul.appendChild(li);
  });
}

function projectMenu(isInbox = false) {
  return new Promise((resolve) => {
    const modal = el('#modal');
    el('#modal-title').textContent = 'Project Action';
    el('#modal-body').innerHTML = `
      <p>Choose an action:</p>
      <div class="form-group" style="margin-top: 16px;">
        <button id="rename-action" class="modal-actions button" style="width: 100%; margin-bottom: 8px; padding: 12px;">Rename Project</button>
        <button id="delete-action" class="modal-actions button" style="width: 100%; padding: 12px; ${isInbox ? 'display: none;' : ''}">Delete Project</button>
      </div>
    `;
    modal.classList.remove('hidden');

    const renameBtn = el('#rename-action');
    const deleteBtn = el('#delete-action');
    const cancel = el('#modal-cancel');

    const finish = (choice) => {
      modal.classList.add('hidden');
      resolve(choice);
    };

    renameBtn.onclick = () => finish('rename');
    deleteBtn.onclick = () => finish('delete');
    cancel.onclick = () => finish(null);

    // Hide delete button for inbox project
    if (isInbox) {
      deleteBtn.style.display = 'none';
    }
  });
}

function renderNewTaskProjectSelect() {
  const sel = el('#new-project');
  sel.innerHTML = '';
  const projects = state.db?.projects || [];
  
  projects.forEach((p) => {
    const opt = document.createElement('option');
    opt.value = p.id;
    opt.textContent = p.name;
    sel.appendChild(opt);
  });
  if (state.view.type === 'project' && state.view.projectId) sel.value = state.view.projectId;
  else sel.value = 'inbox';
  
  // Set default due date to today
  const dueDateInput = el('#new-due');
  if (dueDateInput) {
    dueDateInput.value = dateToYMD(new Date());
  }
}

function renderHeaderTitle() {
  const h = el('#view-title');
  
  if (state.view.type === 'today') h.textContent = 'Today';
  else if (state.view.type === 'week') h.textContent = 'Week';
  else if (state.view.type === 'all') h.textContent = 'All tasks';
  else {
    const p = (state.db?.projects || []).find((x) => x.id === state.view.projectId);
    h.textContent = p ? p.name : 'Project';
  }
}

function renderTasks() {
  const container = el('#task-container');
  container.innerHTML = '';

  if (state.view.type === 'week') {
    return renderWeekList(container);
  }

  const tasks = getFilteredTasks();
  
  if (!tasks.length) {
    container.innerHTML = `<div style="padding:16px;color:#8a94a6;">No tasks yet.</div>`;
    return;
  }
  tasks.forEach((t) => container.appendChild(renderTaskItem(t)));
}

/* ---------- NEW: Vertical Week view ---------- */
function renderWeekList(container) {
  const list = document.createElement('div');
  list.className = 'week-list';

  const today = startOfDay(new Date());

  for (let i = 0; i < 7; i++) {
    const d = addDays(today, i);
    const ymd = dateToYMD(d);

    const section = document.createElement('section');
    section.className = 'day-section';

    const header = document.createElement('header');
    header.className = 'day-header';

    const nameSpan = document.createElement('span');
    nameSpan.className = 'day-name';
    nameSpan.textContent = d.toLocaleDateString(undefined, { weekday: 'short' });

    const dateSpan = document.createElement('span');
    dateSpan.className = 'day-date';
    dateSpan.textContent = d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });

    header.appendChild(nameSpan);
    header.appendChild(dateSpan);
    section.appendChild(header);

    const body = document.createElement('div');
    body.className = 'day-body';

    const tasks = (state.db?.tasks || [])
      .filter((t) => (state.showCompleted ? true : !t.completed))
      .filter((t) => t.dueDate === ymd);

    console.log(`Day ${ymd}: showCompleted=${state.showCompleted}, total tasks=${tasks.length}, completed=${tasks.filter(t => t.completed).length}`);

    // Add tasks first
    if (tasks.length > 0) {
      sortTasks(tasks).forEach((t) => body.appendChild(renderTaskItem(t)));
    }

    // Add task creation input inline (always show)
    const taskInput = document.createElement('div');
    taskInput.className = 'day-task-input';
    
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = 'Add a task...';
    input.className = 'day-task-title-input';
    
    const addBtn = document.createElement('button');
    addBtn.textContent = '+';
    addBtn.className = 'day-task-add-btn';
    addBtn.title = 'Add task';
    addBtn.disabled = true; // Start disabled
    
    // Handle task creation for this specific day
    const handleAddTask = async () => {
      const title = input.value.trim();
      if (!title) return;
      
      try {
        const created = await api.addTask({
          title,
          dueDate: ymd, // Set due date to this specific day
          priority: 0,
          tags: [],
          projectId: 'inbox'
        });
        
        // Clear input and refresh
        input.value = '';
        addBtn.disabled = true; // Disable button after clearing
        await loadAndRender();
        
        // Switch to week view to show the new task
        state.view = { type: 'week', projectId: null };
        renderAll();
      } catch (err) {
        console.error('Failed to add task:', err);
        alert(`Failed to add task: ${err?.message || err}`);
      }
    };
    
    // Enable/disable button based on input text
    const updateButtonState = () => {
      addBtn.disabled = !input.value.trim();
    };
    
    input.addEventListener('input', updateButtonState);
    input.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && input.value.trim()) {
        handleAddTask();
      }
    });
    
    addBtn.addEventListener('click', handleAddTask);
    
    taskInput.appendChild(input);
    taskInput.appendChild(addBtn);
    body.appendChild(taskInput);

    section.appendChild(body);
    list.appendChild(section);
  }

  container.appendChild(list);
}

/* ---------- Task item ---------- */
function renderTaskItem(t) {
  const tpl = el('#task-item-template');
  const node = tpl.content.firstElementChild.cloneNode(true);

  const cb = node.querySelector('.complete-checkbox');
  cb.checked = !!t.completed;
  cb.addEventListener('change', async () => {
    await api.updateTask({ id: t.id, completed: cb.checked });
    await loadAndRender();
  });

  node.querySelector('.task-title').textContent = t.title;

  const meta = node.querySelector('.task-meta');
  meta.innerHTML = '';
  
  // Add priority indicator
  if (t.priority > 0) {
    const priorityIndicator = document.createElement('span');
    priorityIndicator.className = `priority-indicator p${t.priority}`;
    priorityIndicator.title = `Priority ${t.priority}`;
    meta.appendChild(priorityIndicator);
  }
  
  if (t.projectId) {
    const p = (state.db?.projects || []).find((x) => x.id === t.projectId);
    if (p) meta.appendChild(chip(p.name));
  }
  if (t.dueDate) meta.appendChild(chip(`Due ${formatYMD(t.dueDate)}`));
  if (t.priority > 0) {
    const priorityChip = chip(`P${t.priority}`);
    priorityChip.className += ` priority-${t.priority}`;
    meta.appendChild(priorityChip);
  }
  (t.tags || []).forEach((tag) => meta.appendChild(chip(`#${tag}`)));
  if (t.completed && t.dateCompleted)
    meta.appendChild(chip(`Done ${formatDateTime(t.dateCompleted)}`));

  const editBtn = node.querySelector('.edit-btn');
  const delBtn = node.querySelector('.delete-btn');

  editBtn.addEventListener('click', async () => {
    const editResult = await promptModal({
      title: 'Edit Task',
      bodyHTML: `
        <div class="form-group">
          <label for="edit-title">Title</label>
          <input id="edit-title" type="text" value="${t.title}" />
        </div>
        <div class="form-group">
          <label for="edit-description">Description</label>
          <textarea id="edit-description">${t.description || ''}</textarea>
        </div>
        <div class="form-group">
          <label for="edit-due">Due Date</label>
          <input id="edit-due" type="date" value="${t.dueDate || ''}" />
        </div>
        <div class="form-group">
          <label for="edit-priority">Priority</label>
          <select id="edit-priority">
            <option value="0" ${t.priority === 0 ? 'selected' : ''}>None</option>
            <option value="1" ${t.priority === 1 ? 'selected' : ''} style="color: var(--priority-1); font-weight: 600;">1</option>
            <option value="2" ${t.priority === 2 ? 'selected' : ''} style="color: var(--priority-2); font-weight: 600;">2</option>
            <option value="3" ${t.priority === 3 ? 'selected' : ''} style="color: var(--priority-3); font-weight: 600;">3</option>
          </select>
        </div>
        <div class="form-group">
          <label for="edit-tags">Tags (comma-separated)</label>
          <input id="edit-tags" type="text" value="${(t.tags || []).join(', ')}" />
        </div>
        <div class="form-group">
          <label for="edit-project">Project</label>
          <select id="edit-project">
            ${(state.db?.projects || []).map(p => 
              `<option value="${p.id}" ${p.id === t.projectId ? 'selected' : ''}>${p.name}</option>`
            ).join('')}
          </select>
        </div>
      `,
      okText: 'Save',
    });
    
    if (!editResult) return; // user cancelled
    
    const newTitle = el('#edit-title')?.value;
    const newDesc = el('#edit-description')?.value;
    const newDue = el('#edit-due')?.value;
    const newPriority = el('#edit-priority')?.value;
    const newTags = el('#edit-tags')?.value;
    const newProjectId = el('#edit-project')?.value;
    
    if (!newTitle || !newTitle.trim()) {
      alert('Title is required');
      return;
    }

    // Date picker validation is simpler - it's either empty or a valid date
    const dueTrim = newDue?.trim() || '';
    const dueValid = !dueTrim || /^\d{4}-\d{2}-\d{2}$/.test(dueTrim);
    if (!dueValid) {
      alert('Invalid date format.');
      return;
    }

    const pr = Number(newPriority);
    if (!Number.isInteger(pr) || pr < 0 || pr > 3) {
      alert('Priority must be an integer between 0 and 3.');
      return;
    }

    const updateData = {
      id: t.id,
      title: newTitle.trim(),
      description: newDesc || '',
      dueDate: dueTrim ? dueTrim : null,
      priority: pr,
      tags: newTags
        .split(',')
        .map((s) => s.trim())
        .filter(Boolean),
      projectId: newProjectId,
    };

    console.log('Updating task with data:', updateData);

    await api
      .updateTask(updateData)
      .catch((err) => {
        console.error('updateTask failed', err);
        alert('Failed to update task. Check console for details.');
      });
    
    // Close the modal and refresh the view
    await loadAndRender();
    
    // If we're in week view and the date changed, make sure to stay in week view
    if (state.view.type === 'week' && updateData.dueDate !== t.dueDate) {
      // The task might have moved to a different day, so refresh week view
      state.view = { type: 'week', projectId: null };
      renderAll();
    }
  });

  delBtn.addEventListener('click', async () => {
    if (!confirm('Delete this task?')) return;
    await api.deleteTask(t.id);
    await loadAndRender();
  });

  return node;
}

function chip(text) {
  const span = document.createElement('span');
  span.className = 'chip';
  span.textContent = text;
  return span;
}

/* ---------- Filtering ---------- */
function getFilteredTasks() {
  const all = state.db?.tasks || [];
  
  if (state.view.type === 'all') {
    const filtered = sortTasks(all.filter((t) => state.showCompleted || !t.completed));
    return filtered;
  }
  if (state.view.type === 'project') {
    const filtered = all.filter((t) => t.projectId === state.view.projectId);
    const result = sortTasks(filtered.filter((t) => state.showCompleted || !t.completed));
    return result;
  }
  if (state.view.type === 'today') {
    const ymd = dateToYMD(new Date());
    const filtered = all.filter((t) => {
      if (!state.showCompleted && t.completed) return false;
      if (t.dueDate) return t.dueDate <= ymd;
      return true;
    });
    const result = sortTasks(filtered);
    return result;
  }
  const result = sortTasks(all.filter((t) => state.showCompleted || !t.completed));
  return result;
}

/* ---------- Add Task ---------- */
async function onAddTask() {
  const title = el('#new-title').value.trim();
  if (!title) {
    alert('Title is required');
    return;
  }
  
  // Get values from option inputs (they might be hidden)
  const dueDate = el('#new-due')?.value || null;
  const priority = Number(el('#new-priority')?.value || '0');
  const tags = (el('#new-tags')?.value || '')
    .split(',')
    .map((s) => s.trim())
    .filter(Boolean);
  const projectId = el('#new-project')?.value || 'inbox';

  // Basic validation for add
  // Date picker validation is simpler - it's either empty or a valid date
  if (dueDate && !/^\d{4}-\d{2}-\d{2}$/.test(dueDate)) {
    alert('Invalid date format.');
    return;
  }
  if (!Number.isInteger(priority) || priority < 0 || priority > 3) {
    alert('Priority must be an integer between 0 and 3.');
    return;
  }

  let created;
  try {
    created = await api.addTask({ title, dueDate, priority, tags, projectId });
  } catch (e) {
    console.error('addTask failed', e);
    alert('Failed to add task. See console for details.');
    return;
  }

  // Clear inputs and close option panels
  el('#new-title').value = '';
  if (el('#new-due')) el('#new-due').value = dateToYMD(new Date());
  if (el('#new-tags')) el('#new-tags').value = '';
  closeAllOptionInputs();
  
  await loadAndRender();

  if (created?.dueDate) {
    const todayYMD = dateToYMD(new Date());
    const inNext7 =
      created.dueDate >= todayYMD && created.dueDate <= dateToYMD(addDays(new Date(), 6));
    if (inNext7) {
      state.view = { type: 'week', projectId: null };
    } else {
      state.view = { type: 'project', projectId: created.projectId || 'inbox' };
    }
  } else {
    // No due date -> All is safest to ensure visibility
    state.view = { type: 'all', projectId: null };
  }
  renderAll();
}

/* ---------- Utilities ---------- */
function addDays(d, n) {
  const c = new Date(d);
  c.setDate(c.getDate() + n);
  return c;
}
function startOfDay(d) {
  const c = new Date(d);
  c.setHours(0, 0, 0, 0);
  return c;
}
function dateToYMD(d) {
  const dt = d instanceof Date ? d : new Date(d);
  const y = dt.getFullYear();
  const m = String(dt.getMonth() + 1).padStart(2, '0');
  const day = String(dt.getDate()).padStart(2, '0');
  return `${y}-${m}-${day}`;
}
function formatYMD(s) {
  try {
    const d = new Date(s);
    return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
  } catch {
    return s;
  }
}
function formatDateTime(s) {
  try {
    const d = new Date(s);
    return d.toLocaleString();
  } catch {
    return s;
  }
}
function sortTasks(arr) {
  const sorted = arr.slice().sort((a, b) => {
    if (a.completed !== b.completed) return a.completed ? 1 : -1;
    if (a.dueDate && b.dueDate) {
      if (a.dueDate < b.dueDate) return -1;
      if (a.dueDate > b.dueDate) return 1;
    } else if (a.dueDate && !b.dueDate) return -1;
    else if (!a.dueDate && b.dueDate) return 1;
    if ((b.priority || 0) !== (a.priority || 0)) return (b.priority || 0) - (a.priority || 0);
    return new Date(a.createdAt) - new Date(b.createdAt);
  });
  return sorted;
}
function getProjectName(id) {
  return (state.db?.projects || []).find((p) => p.id === id)?.name || 'Inbox';
}
function projectIdByName(name) {
  if (!name) return null;
  const p = (state.db?.projects || []).find((p) => p.name.toLowerCase() === name.toLowerCase());
  return p?.id || null;
}

/* Global error surfacing */
window.addEventListener('unhandledrejection', (e) => {
  console.error('Unhandled promise rejection:', e.reason);
  alert('Something went wrong. Check the console for details.');
});
window.addEventListener('error', (e) => {
  console.error('Unhandled error:', e.error || e.message);
});
==> src/renderer/index.html <==
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Private Todo</title>
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:;"
    />
    <link rel="stylesheet" href="./styles.css" />
  </head>
  <body>
    <!-- Custom Title Bar -->
    <div class="titlebar" id="titlebar">
      <div class="tb-left">
        <button class="tb-btn tb-close" title="Close"></button>
        <button class="tb-btn tb-min" title="Minimize"></button>
        <button class="tb-btn tb-max" title="Maximize"></button>
      </div>
      <div class="tb-center">
        <span class="titlebar-title">Private Todo</span>
      </div>
      <div class="tb-right"></div>
    </div>

    <div id="app">
      <aside class="sidebar">
        <div class="sidebar-header">
          <h1>Private Todo</h1>
        </div>

        <nav class="nav">
          <button class="nav-item" data-view="today">Today</button>
          <button class="nav-item" data-view="week">Week</button>
          <button class="nav-item" data-view="all">All</button>
        </nav>

        <div class="projects">
          <div class="projects-header">
            <span>Projects</span>
            <button id="add-project-btn" title="Add project">+</button>
          </div>
          <ul id="project-list"></ul>
        </div>

        <div class="sidebar-footer">
          <button id="export-btn" title="Export backup">Backup</button>
          <button id="import-btn" title="Restore backup">Restore</button>
        </div>
      </aside>

      <main class="main">
        <header class="main-header">
          <h2 id="view-title">Today</h2>
          <div class="spacer"></div>
        </header>

        <section class="task-input">
          <div class="task-input-main">
            <input id="new-title" placeholder="Add a new task..." />
          </div>
          <div class="task-input-options">
            <div class="option-group">
              <button class="option-btn" id="due-date-btn" title="Set due date">
                <span class="option-icon">📅</span>
                <span class="option-label">Date</span>
              </button>
              <div class="option-input" id="due-date-input" style="display: none;">
                <input type="date" id="new-due" />
              </div>
            </div>

            <div class="option-group">
              <button class="option-btn" id="priority-btn" title="Set priority">
                <span class="option-icon">⚡</span>
                <span class="option-label">Priority</span>
              </button>
              <div class="option-input" id="priority-input" style="display: none">
                <select id="new-priority">
                  <option value="0">None</option>
                  <option value="1" style="color: var(--priority-1); font-weight: 600">1</option>
                  <option value="2" style="color: var(--priority-2); font-weight: 600">2</option>
                  <option value="3" style="color: var(--priority-3); font-weight: 600">3</option>
                </select>
              </div>
            </div>

            <div class="option-group">
              <button class="option-btn" id="tags-btn" title="Add tags">
                <span class="option-icon">🏷️</span>
                <span class="option-label">Tags</span>
              </button>
              <div class="option-input" id="tags-input" style="display: none">
                <input type="text" id="new-tags" placeholder="tags (comma-separated)" />
              </div>
            </div>

            <div class="option-group">
              <button class="option-btn" id="project-btn" title="Set project">
                <span class="option-icon">📁</span>
                <span class="option-label">Project</span>
              </button>
              <div class="option-input" id="project-input" style="display: none">
                <select id="new-project"></select>
              </div>
            </div>
          </div>
        </section>

        <section id="task-container" class="task-container"></section>

        <footer class="main-footer">
          <button id="view-completed-btn" class="linklike">View completed</button>
        </footer>
      </main>
    </div>

    <!-- Simple modals -->
    <div id="modal" class="modal hidden">
      <div class="modal-card">
        <h3 id="modal-title"></h3>
        <div id="modal-body"></div>
        <div class="modal-actions">
          <button id="modal-cancel">Cancel</button>
          <button id="modal-ok">OK</button>
        </div>
      </div>
    </div>

    <template id="task-item-template">
      <div class="task-item">
        <label class="checkbox"><input type="checkbox" class="complete-checkbox" /></label>
        <div class="task-main">
          <div class="task-title"></div>
          <div class="task-meta"></div>
        </div>
        <details class="task-menu">
          <summary>⋯</summary>
          <div class="menu">
            <button class="edit-btn">Edit</button>
            <button class="delete-btn">Delete</button>
          </div>
        </details>
      </div>
    </template>

    <script src="./renderer.js"></script>
  </body>
</html>
==> src/renderer/styles.css <==
:root {
  --bg: #111418;
  --panel: #171b21;
  --text: #e9eef5;
  --muted: #a1adbd;
  --accent: #da524d; /* subtle red accent */
  --line: #232a33;
  --chip: #273243;
  
  /* Priority colors */
  --priority-1: #ff6b6b; /* red */
  --priority-2: #ffd93d; /* yellow */
  --priority-3: #4ecdc4; /* blue */
}

* {
  box-sizing: border-box;
}

html,
body,
#app {
  height: 100%;
  margin: 0;
  background: var(--bg);
  color: var(--text);
  font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
}

/* ===== Custom Title Bar (frameless) ===== */
body {
  padding-top: 40px;
} /* room for the fixed bar */

.titlebar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 40px;
  background: var(--panel);
  border-bottom: 1px solid var(--line);
  display: grid;
  grid-template-columns: 120px 1fr 120px; /* left buttons / center title / right actions */
  align-items: center;
  z-index: 1000;
  -webkit-app-region: drag;
  user-select: none;
}

.tb-left,
.tb-center,
.tb-right {
  display: flex;
  align-items: center;
}

.tb-left {
  gap: 8px;
  padding-left: 10px;
}
.tb-center {
  justify-content: center;
  pointer-events: none;
} /* keep center fully draggable */
.tb-right {
  justify-content: flex-end;
  padding-right: 10px;
}

.titlebar-title {
  color: var(--muted);
  font-size: 13px;
  letter-spacing: 0.2px;
}

.tb-btn {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 1px solid transparent;
  -webkit-app-region: no-drag; /* clickable, not draggable */
  cursor: pointer;
  padding: 0;
  outline: none;
}

.tb-close {
  background: #ff5f57;
  border-color: #d44b45;
}
.tb-min {
  background: #ffbd2e;
  border-color: #d09b26;
}
.tb-max {
  background: #28c840;
  border-color: #1da431;
}
.tb-btn:hover {
  filter: brightness(1.07);
}

/* Ensure app content is clickable (non-drag) */
.sidebar,
.main,
.modal,
.task-input,
.task-container,
button,
input,
select,
details,
summary,
.task-item,
.menu {
  -webkit-app-region: no-drag;
}

/* ===== App Layout ===== */
#app {
  display: grid;
  grid-template-columns: 280px 1fr;
}

/* ===== Sidebar ===== */
.sidebar {
  min-width: 250px;
  width: 250px;
  flex-shrink: 0;
  background: var(--panel);
  border-right: 1px solid var(--line);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  height: 100%;
}

.sidebar-header {
  padding: 16px;
  border-bottom: 1px solid var(--line);
  flex-shrink: 0;
}

.sidebar-header h1 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
}

.nav {
  padding: 16px;
  flex-shrink: 0;
}

.nav-item {
  width: 100%;
  text-align: left;
  padding: 8px 12px;
  margin-bottom: 4px;
  background: transparent;
  border: none;
  color: var(--text);
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.15s ease;
}

.nav-item:hover {
  background: var(--line);
}

.nav-item.active {
  background: var(--accent);
  color: white;
}

.projects {
  flex: 1;
  padding: 16px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  min-height: 0; /* Important for flexbox scrolling */
}

.projects-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  flex-shrink: 0;
}

#project-list {
  list-style: none;
  padding: 0;
  margin: 0;
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  min-height: 0; /* Important for flexbox scrolling */
}

#project-list::-webkit-scrollbar {
  width: 6px;
}

#project-list::-webkit-scrollbar-track {
  background: transparent;
}

#project-list::-webkit-scrollbar-thumb {
  background: var(--line);
  border-radius: 3px;
}

#project-list::-webkit-scrollbar-thumb:hover {
  background: var(--muted);
}

#project-list li {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
#project-list button {
  background: transparent;
  border: none;
  color: var(--muted);
  cursor: pointer;
}
.project-item {
  width: 100%;
  text-align: left;
  padding: 8px 10px;
  margin: 2px 0;
  background: transparent;
  border: none;
  color: var(--text);
  border-radius: 6px;
  cursor: pointer;
}
.project-item:hover {
  background: #1e242c;
}

.sidebar-footer {
  padding: 16px;
  border-top: 1px solid var(--line);
  flex-shrink: 0;
  display: flex;
  gap: 8px;
}
.sidebar-footer button {
  flex: 1;
  padding: 8px 12px;
  background: var(--line);
  border: 1px solid var(--line);
  color: var(--text);
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
}
.sidebar-footer button:hover {
  filter: brightness(1.1);
}

/* ===== Main Panel ===== */
.main {
  display: flex;
  flex-direction: column;
  height: 100%;
}
/* Ensure main content remains usable */
.main-header {
  padding: 16px;
  border-bottom: 1px solid var(--line);
  display: flex;
  align-items: center;
  gap: 16px;
  flex-shrink: 0;
}

.main-header h2 {
  margin: 0;
  font-size: 20px;
  font-weight: 600;
}

.spacer {
  flex: 1;
}

.toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
}

.toggle input[type="checkbox"] {
  margin: 0;
}

/* ===== New Task Input ===== */
.task-input {
  display: grid;
  grid-template-columns: 2fr 140px 160px 1fr 1fr auto;
  gap: 8px;
  padding: 12px 16px;
  border-bottom: 1px solid var(--line);
}
.task-input input,
.task-input select,
.task-input button {
  background: #1a2028;
  border: 1px solid #2b3441;
  color: var(--text);
  border-radius: 8px;
  padding: 10px;
}
.task-input button {
  cursor: pointer;
}

/* ===== Task List Container ===== */
.task-container {
  padding: 10px 12px 40px;
  overflow: auto;
  flex: 1;
}

/* ===== Task Item ===== */
.task-item {
  display: grid;
  grid-template-columns: 32px 1fr 40px;
  gap: 8px;
  align-items: start;
  padding: 10px;
  border-bottom: 1px solid var(--line);
}
.checkbox {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 24px;
}
.checkbox input {
  width: 18px;
  height: 18px;
  cursor: pointer;
}

.task-main {
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.task-title {
  font-weight: 600;
}
.task-meta {
  color: var(--muted);
  font-size: 12px;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}
.chip {
  background: var(--chip);
  color: var(--text);
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 500;
  display: inline-block;
  margin: 2px;
}

.chip.priority-1 {
  background: var(--priority-1);
  color: #000;
  font-weight: 600;
}

.chip.priority-2 {
  background: var(--priority-2);
  color: #000;
  font-weight: 600;
}

.chip.priority-3 {
  background: var(--priority-3);
  color: #000;
  font-weight: 600;
}

.priority-indicator {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 8px;
}

.priority-indicator.p1 {
  background: var(--priority-1);
}

.priority-indicator.p2 {
  background: var(--priority-2);
}

.priority-indicator.p3 {
  background: var(--priority-3);
}

/* ⋯ menu (details) */
.task-menu {
  position: relative;
}
.task-menu summary {
  list-style: none;
  cursor: pointer;
  color: var(--muted);
  font-size: 18px;
  line-height: 18px;
}
.task-menu summary::-webkit-details-marker {
  display: none;
}

/* Larger, non-clipping menu */
.task-menu .menu {
  position: absolute;
  right: 0;
  top: 22px;
  min-width: 180px;
  z-index: 2000;
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 10px;
  background: #1f2630;
  border: 1px solid #2b3645;
  border-radius: 8px;
  white-space: nowrap;
  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
}
.task-menu button {
  background: transparent;
  border: 1px solid #364556;
  color: var(--text);
  border-radius: 6px;
  padding: 8px 12px;
  font-size: 13px;
  cursor: pointer;
}
.task-menu button:hover {
  filter: brightness(1.1);
}

/* ===== Week view: vertical ===== */
.week-list {
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding: 12px 16px 24px;
}

.day-section {
  border: 1px solid var(--line);
  border-radius: 10px;
  overflow: hidden;
}

.day-header {
  padding: 10px 12px;
  background: #1c222b;
  border-bottom: 1px solid var(--line);
  display: flex;
  align-items: baseline;
  gap: 10px;
}

.day-header .day-name {
  font-weight: 700;
}
.day-header .day-date {
  color: var(--muted);
  font-size: 12px;
}

.day-body {
  padding: 8px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.day-empty {
  color: #8a94a6;
  padding: 6px 8px;
}

/* ===== Footer ===== */
.main-footer {
  padding: 10px 16px;
  border-top: 1px solid var(--line);
}
.linklike {
  background: transparent;
  border: none;
  color: var(--muted);
  cursor: pointer;
  text-decoration: underline;
}

/* ===== Modal ===== */
.modal.hidden {
  display: none;
}
.modal {
  position: fixed;
  inset: 0;
  display: grid;
  place-items: center;
  background: rgba(0, 0, 0, 0.45);
}
.modal-card {
  width: 420px;
  background: #1b212a;
  border: 1px solid #2e3948;
  border-radius: 10px;
  padding: 16px;
}
.modal-card h3 {
  margin-top: 0;
}
.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 12px;
}
.modal-actions button {
  background: #2a3647;
  border: 1px solid #3a485d;
  color: var(--text);
  border-radius: 8px;
  padding: 8px 14px;
  cursor: pointer;
  transition: transform 0.02s ease, filter 0.15s ease;
}
.modal-actions button:hover {
  filter: brightness(1.08);
}
.modal-actions button:active {
  transform: translateY(1px);
}

.modal-card input[type='password'],
.modal-card input[type='text'],
.modal-card input[type='checkbox'] {
  width: 100%;
  background: #1a2028;
  border: 1px solid #2b3441;
  color: var(--text);
  border-radius: 8px;
  padding: 10px;
  font-size: 14px;
  transition: border-color 0.15s ease;
}

.modal-card input[type='text']:focus,
.modal-card input[type='password']:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(218, 82, 77, 0.2);
}

.modal-card textarea {
  width: 100%;
  background: #1a2028;
  border: 1px solid #2b3441;
  color: var(--text);
  border-radius: 8px;
  padding: 10px;
  font-size: 14px;
  font-family: inherit;
  resize: vertical;
  min-height: 60px;
  transition: border-color 0.15s ease;
}

.modal-card textarea:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(218, 82, 77, 0.2);
}

.modal-card select {
  width: 100%;
  background: #1a2028;
  border: 1px solid #2b3441;
  color: var(--text);
  border-radius: 8px;
  padding: 10px;
  font-size: 14px;
  cursor: pointer;
  transition: border-color 0.15s ease;
}

.modal-card select:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(218, 82, 77, 0.2);
}

.modal-card label {
  color: var(--muted);
  display: block;
  margin-bottom: 6px;
  font-size: 13px;
  font-weight: 500;
}

.modal-card .form-group {
  margin-bottom: 16px;
}

.modal-card .form-group:last-child {
  margin-bottom: 0;
}

.modal-card .form-group button {
  background: #2a3647;
  border: 1px solid #3a485d;
  color: var(--text);
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.02s ease, filter 0.15s ease;
  font-size: 14px;
  font-weight: 500;
}

.modal-card .form-group button:hover {
  filter: brightness(1.08);
}

.modal-card .form-group button:active {
  transform: translateY(1px);
}

.modal-card .form-group button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* ===== Buttons (global) ===== */
button {
  transition: transform 0.02s ease, filter 0.15s ease, background 0.15s ease,
    border-color 0.15s ease;
}
button:active {
  transform: translateY(1px);
}

/* Primary-ish buttons */
#add-task-btn,
.sidebar-footer button {
  background: #2a3647;
  border: 1px solid #3a485d;
}
#add-task-btn:hover,
.sidebar-footer button:hover {
  filter: brightness(1.08);
}

/* Project "+" button */
#add-project-btn {
  background: #223041;
  border: 1px solid #334154;
  width: 28px;
  height: 28px;
  display: grid;
  place-items: center;
}
#add-project-btn:hover {
  filter: brightness(1.08);
}

/* Nav active state */
.nav-item.active,
.nav-item:focus-visible {
  background: #1e242c;
  outline: 1px solid #2b3441;
}

/* ===== Week View ===== */
.week-list {
  display: flex;
  gap: 20px;
  overflow-x: auto;
  padding: 20px;
}

.day-section {
  min-width: 280px;
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 12px;
  overflow: hidden;
}

.day-header {
  background: var(--line);
  padding: 8px 12px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.day-name {
  font-weight: 600;
  color: var(--text);
}

.day-date {
  color: var(--muted);
  font-size: 13px;
}

.day-body {
  padding: 12px;
  min-height: 120px;
}

.day-empty {
  display: none;
}

.day-task-input {
  display: flex;
  gap: 8px;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--line);
}

.day-task-title-input {
  flex: 1;
  background: transparent;
  border: none;
  border-bottom: 2px solid var(--line);
  color: var(--text);
  padding: 8px 0;
  font-size: 14px;
  transition: border-color 0.15s ease;
}

.day-task-title-input:focus {
  outline: none;
  border-bottom-color: var(--accent);
}

.day-task-title-input::placeholder {
  color: var(--muted);
  opacity: 0.7;
}

.day-task-add-btn {
  background: var(--accent);
  border: 1px solid var(--accent);
  color: white;
  border-radius: 6px;
  padding: 8px 12px;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.15s ease;
  min-width: 40px;
}

.day-task-add-btn:hover:not(:disabled) {
  filter: brightness(1.1);
}

.day-task-add-btn:active:not(:disabled) {
  transform: translateY(1px);
}

.day-task-add-btn:disabled {
  background: var(--line);
  border-color: var(--line);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.6;
}

/* ===== Responsive Design & Layout Constraints ===== */
#app {
  min-width: 800px;
  min-height: 600px;
  display: flex;
  height: 100%;
}

.sidebar {
  min-width: 250px;
  width: 250px;
  flex-shrink: 0;
  background: var(--panel);
  border-right: 1px solid var(--line);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.main {
  flex: 1;
  min-width: 550px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Responsive adjustments for smaller screens */
@media (max-width: 1000px) {
  .sidebar {
    width: 220px;
    min-width: 220px;
  }
  
  .main {
    min-width: 500px;
  }
  
  .week-list {
    gap: 15px;
    padding: 15px;
  }
  
  .day-section {
    min-width: 250px;
  }
}

@media (max-width: 900px) {
  .sidebar {
    width: 200px;
    min-width: 200px;
  }
  
  .main {
    min-width: 450px;
  }
  
  .week-list {
    gap: 10px;
    padding: 10px;
  }
  
  .day-section {
    min-width: 220px;
  }
}

/* Ensure task input remains usable */
.task-input {
  min-width: 500px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 16px;
  background: var(--panel);
  border-bottom: 1px solid var(--line);
}

.task-input-main {
  display: flex;
  gap: 8px;
  align-items: center;
}

.task-input-main input {
  flex: 1;
  min-width: 200px;
  background: var(--bg);
  border: 1px solid var(--line);
  color: var(--text);
  border-radius: 8px;
  padding: 12px;
  font-size: 14px;
  transition: border-color 0.15s ease;
}

.task-input-main input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(218, 82, 77, 0.2);
}

.task-input-options {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
}

.option-group {
  position: relative;
}

.option-btn {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 6px;
  background: transparent;
  border: 1px solid var(--line);
  color: var(--muted);
  border-radius: 6px;
  padding: 6px 10px;
  cursor: pointer;
  transition: all 0.15s ease;
  min-width: 50px;
  height: 32px;
}

.option-btn:hover {
  border-color: var(--accent);
  color: var(--text);
  background: var(--line);
}

.option-btn.active {
  border-color: var(--accent);
  color: var(--accent);
  background: var(--line);
}

.option-icon {
  font-size: 14px;
}

.option-label {
  font-size: 12px;
  font-weight: 500;
}

.option-input {
  position: absolute;
  top: 100%;
  left: 0;
  margin-top: 8px;
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 8px;
  padding: 12px;
  min-width: 200px;
  z-index: 100;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.option-input input,
.option-input select {
  width: 100%;
  background: var(--bg);
  border: 1px solid var(--line);
  color: var(--text);
  border-radius: 6px;
  padding: 8px 12px;
  font-size: 14px;
  margin-bottom: 8px;
}

.option-input input:last-child,
.option-input select:last-child {
  margin-bottom: 0;
}

.option-input input:focus,
.option-input select:focus {
  outline: none;
  border-color: var(--accent);
}

#new-title {
  min-width: 200px;
  flex: 2;
}

/* Ensure week view remains scrollable */
.week-list {
  min-width: 100%;
  overflow-x: auto;
  overflow-y: hidden;
}

/* Ensure task container remains usable */
.task-container {
  flex: 1;
  overflow: auto;
  min-height: 200px;
}

/* Ensure week view remains usable at small sizes */
@media (max-width: 800px) {
  .week-list {
    flex-direction: column;
    gap: 10px;
    padding: 10px;
  }
  
  .day-section {
    min-width: auto;
    width: 100%;
  }
  
  .task-input {
    flex-direction: column;
    min-width: auto;
  }
  
  .task-input > * {
    min-width: auto;
    width: 100%;
  }
}
==> src/preload.cjs <==
// src/preload.cjs  (CommonJS)
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('api', {
  /* Security */
  securityGetConfig: () => ipcRenderer.invoke('security:getConfig'),
  securityEnable: (passcode, useBiometrics) =>
    ipcRenderer.invoke('security:enable', { passcode, useBiometrics }),
  securityUnlock: (passcode) => ipcRenderer.invoke('security:unlock', { passcode }),
  securityLock: () => ipcRenderer.invoke('security:lock'),

  /* DB merged view */
  loadDB: () => ipcRenderer.invoke('db:load'),

  /* Projects */
  addProject: (name) => ipcRenderer.invoke('project:add', name),
  renameProject: (id, name) => ipcRenderer.invoke('project:rename', { id, name }),
  deleteProject: (id) => ipcRenderer.invoke('project:delete', id),

  /* Tasks */
  addTask: (task) => ipcRenderer.invoke('task:add', task),
  updateTask: (partial) => ipcRenderer.invoke('task:update', partial),
  deleteTask: (id) => ipcRenderer.invoke('task:delete', id),

  /* Backup */
  exportBackup: () => ipcRenderer.invoke('backup:export'),
  importBackup: () => ipcRenderer.invoke('backup:import'),
});
==> src/main.js <==
import { app, BrowserWindow, ipcMain, systemPreferences, dialog } from 'electron';
import { fileURLToPath } from 'node:url';
import { dirname, join, basename } from 'node:path';
import fs from 'node:fs/promises';
import { existsSync } from 'node:fs';
import crypto from 'node:crypto';
import keytar from 'keytar';
import os from 'node:os';

console.log('=== MAIN PROCESS STARTED ===');
console.log('Console.log is working in main process');

const KEYTAR_SERVICE = 'PrivateTodo';
const KEYTAR_ACCOUNT = 'encryption-key';

// ----- ESM-safe pathing (critical fix) -----
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

let mainWindow;
const isDev = process.env.NODE_ENV === 'development';

const ARCHIVE_THRESHOLD = 2000; // move old completed tasks to archive past this count

const userDataDir = app.getPath('userData');
const dbPath = join(userDataDir, 'db.json');
const archivePath = join(userDataDir, 'archive.json');
const settingsPath = join(userDataDir, 'settings.json');

// Session-only key
let sessionKey = null;

const defaultSettings = {
  version: 1,
  encryptionEnabled: false,
  useBiometrics: false,
  kdf: { algo: 'scrypt', N: 16384, r: 8, p: 1, keyLen: 32, salt: null },
};

const defaultDB = {
  version: 1,
  createdAt: new Date().toISOString(),
  projects: [{ id: 'inbox', name: 'Inbox', createdAt: new Date().toISOString() }],
  tasks: [],
};

app.whenReady().then(async () => {
  console.log('App is ready, initializing...');
  await ensureFiles();
  console.log('Files ensured, creating window...');
  await createWindow();
  console.log('Window created, setting up app events...');
  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
  console.log('App initialization complete');
});
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});

async function createWindow() {
  console.log('Creating main window...');
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 800,
    minHeight: 600,
    title: 'Private Todo',
    webPreferences: {
      contextIsolation: true,
      // !!! Use __dirname-based absolute path for preload
      preload: join(__dirname, 'preload.cjs'),
      sandbox: false,
    },
    frame: false,
    backgroundColor: '#111418',
  });
  // !!! Use __dirname to load the renderer HTML
  await mainWindow.loadFile(join(__dirname, 'renderer', 'index.html'));
  console.log('Main window loaded successfully');
  if (isDev) mainWindow.webContents.openDevTools({ mode: 'detach' });
}

/* ---------- File helpers ---------- */
async function ensureFiles() {
  console.log('Ensuring files exist...');
  if (!existsSync(userDataDir)) {
    console.log('Creating user data directory');
    await fs.mkdir(userDataDir, { recursive: true });
  }
  if (!existsSync(settingsPath)) {
    console.log('Creating default settings');
    await writeSettings(defaultSettings);
  }
  if (!existsSync(dbPath)) {
    console.log('Creating default database with structure:', defaultDB);
    await writeJSONFile(dbPath, defaultDB, false);
  }
  console.log('Files ensured successfully');
}

async function readSettings() {
  const raw = await fs.readFile(settingsPath, 'utf8');
  return JSON.parse(raw);
}
async function writeSettings(s) {
  await atomicWrite(settingsPath, JSON.stringify(s, null, 2));
}

async function readJSONFile(file, encrypted) {
  if (!existsSync(file)) {
    console.log(`File does not exist: ${file}`);
    return null;
  }

  try {
    const raw = await fs.readFile(file, 'utf8');
    const obj = JSON.parse(raw);

    console.log(`readJSONFile ${file}:`, {
      encrypted,
      hasData: !!obj,
      dataType: typeof obj,
      hasProjects: !!obj?.projects,
      projectsCount: obj?.projects?.length || 0,
    });

    if (encrypted) {
      if (!obj || obj._enc !== true) throw new Error('Expected encrypted file');
      if (!sessionKey) throw new Error('Locked: no session key');
      return decryptPayload(obj, sessionKey);
    }
    return obj;
  } catch (error) {
    console.error(`Error reading JSON file ${file}:`, error);
    throw error;
  }
}
async function writeJSONFile(file, data, encrypted) {
  console.log(`writeJSONFile ${file}:`, {
    encrypted,
    hasData: !!data,
    dataType: typeof data,
    hasProjects: !!data?.projects,
    projectsCount: data?.projects?.length || 0,
  });

  if (encrypted) {
    if (!sessionKey) throw new Error('Locked: no session key');
    const payload = encryptPayload(data, sessionKey);
    await atomicWrite(file, JSON.stringify(payload, null, 2));
  } else {
    await atomicWrite(file, JSON.stringify(data, null, 2));
  }

  console.log(`writeJSONFile ${file} completed successfully`);
}
async function atomicWrite(file, contents) {
  const tmp = join(dirname(file), `${basename(file)}.${Date.now()}.tmp`);
  console.log(`atomicWrite ${file}:`, {
    tmpFile: tmp,
    contentLength: contents?.length || 0,
  });

  try {
    await fs.writeFile(tmp, contents, 'utf8');
    await fs.rename(tmp, file);
    console.log(`atomicWrite ${file} completed successfully`);
  } catch (error) {
    console.error(`atomicWrite ${file} failed:`, error);
    // Clean up temp file if it exists
    try {
      if (existsSync(tmp)) await fs.unlink(tmp);
    } catch (cleanupError) {
      console.warn('Failed to cleanup temp file:', cleanupError);
    }
    throw error;
  }
}

/* ---------- Crypto ---------- */
function encryptPayload(obj, key) {
  const iv = crypto.randomBytes(12);
  const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
  const plaintext = Buffer.from(JSON.stringify(obj), 'utf8');
  const enc = Buffer.concat([cipher.update(plaintext), cipher.final()]);
  const tag = cipher.getAuthTag();
  return {
    _enc: true,
    algo: 'aes-256-gcm',
    iv: iv.toString('base64'),
    tag: tag.toString('base64'),
    data: enc.toString('base64'),
  };
}
function decryptPayload(payload, key) {
  const iv = Buffer.from(payload.iv, 'base64');
  const tag = Buffer.from(payload.tag, 'base64');
  const data = Buffer.from(payload.data, 'base64');
  const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
  decipher.setAuthTag(tag);
  const dec = Buffer.concat([decipher.update(data), decipher.final()]);
  return JSON.parse(dec.toString('utf8'));
}
async function deriveKey(pass, settings) {
  if (!settings.kdf?.salt) throw new Error('Missing KDF salt');
  const salt = Buffer.from(settings.kdf.salt, 'base64');
  return new Promise((resolve, reject) => {
    crypto.scrypt(
      pass,
      salt,
      settings.kdf.keyLen,
      { N: settings.kdf.N, r: settings.kdf.r, p: settings.kdf.p },
      (err, derived) => {
        if (err) reject(err);
        else resolve(derived);
      },
    );
  });
}

/* ---------- DB merge & archive ---------- */
async function loadAllData(settings) {
  const enc = !!settings.encryptionEnabled;
  const current = (await readJSONFile(dbPath, enc)) ?? structuredClone(defaultDB);
  let archive = { version: 1, createdAt: current.createdAt, projects: [], tasks: [] };
  if (existsSync(archivePath)) archive = await readJSONFile(archivePath, enc);

  console.log('loadAllData - raw data:', {
    hasCurrent: !!current,
    currentProjects: current?.projects,
    currentProjectsLength: current?.projects?.length || 0,
    hasArchive: !!archive,
    archiveProjects: archive?.projects,
    archiveProjectsLength: archive?.projects?.length || 0,
  });

  const projMap = new Map();
  [...(archive.projects || []), ...(current.projects || [])].forEach((p) => projMap.set(p.id, p));
  const projects = [...projMap.values()];
  const tasks = [...(current.tasks || []), ...(archive.tasks || [])];

  console.log('loadAllData - merged result:', {
    projectsCount: projects.length,
    tasksCount: tasks.length,
    currentProjectsCount: current.projects?.length || 0,
    archiveProjectsCount: archive.projects?.length || 0,
  });

  return { projects, tasks, current, archive };
}
async function saveCurrentAndMaybeArchive(settings, merged) {
  const enc = !!settings.encryptionEnabled;
  let current = merged.current;
  let archive = merged.archive;

  console.log('saveCurrentAndMaybeArchive - input:', {
    hasCurrent: !!current,
    currentProjectsCount: current?.projects?.length || 0,
    currentTasksCount: current?.tasks?.length || 0,
    hasArchive: !!archive,
    archiveProjectsCount: archive?.projects?.length || 0,
    archiveTasksCount: archive?.tasks?.length || 0,
    encryptionEnabled: enc,
  });

  if ((current.tasks?.length || 0) > ARCHIVE_THRESHOLD) {
    const overflow = current.tasks.length - ARCHIVE_THRESHOLD;
    const completed = current.tasks
      .filter((t) => t.completed)
      .sort(
        (a, b) =>
          new Date(a.dateCompleted || a.createdAt) - new Date(b.dateCompleted || b.createdAt),
      );
    const toMove = completed.slice(0, Math.max(0, overflow));
    if (toMove.length) {
      const moveIds = new Set(toMove.map((t) => t.id));
      current.tasks = current.tasks.filter((t) => !moveIds.has(t.id));
      archive.tasks = [...(archive.tasks || []), ...toMove];
      if (!archive.version) archive.version = 1;
      if (!archive.createdAt) archive.createdAt = new Date().toISOString();
    }
  }

  console.log('About to write current DB with projects count:', current.projects?.length || 0);
  await writeJSONFile(dbPath, current, enc);
  console.log('Current DB written successfully');

  if ((archive.tasks?.length || 0) > 0 || existsSync(archivePath)) {
    console.log('About to write archive with projects count:', archive.projects?.length || 0);
    await writeJSONFile(archivePath, archive, enc);
    console.log('Archive written successfully');
  }
}

/* ---------- Biometrics ---------- */
function biometricsAvailable() {
  try {
    return (
      process.platform === 'darwin' &&
      typeof systemPreferences.canPromptTouchID === 'function' &&
      systemPreferences.canPromptTouchID()
    );
  } catch {
    return false;
  }
}

/* ---------- IPC ---------- */

// Settings / Security
ipcMain.handle('security:getConfig', async () => {
  const s = await readSettings();
  return {
    encryptionEnabled: s.encryptionEnabled,
    useBiometrics: s.useBiometrics,
    biometricsAvailable: biometricsAvailable(),
  };
});

ipcMain.handle('security:enable', async (_evt, { passcode, useBiometrics }) => {
  let s = await readSettings();
  if (s.encryptionEnabled) return { ok: true }; // already on
  // create salt
  s.kdf.salt = crypto.randomBytes(16).toString('base64');
  const key = await deriveKey(passcode, s);
  sessionKey = key; // keep in-memory
  s.encryptionEnabled = true;
  s.useBiometrics = !!useBiometrics && biometricsAvailable();
  await writeSettings(s);

  // Store key in Keychain if biometrics chosen
  if (s.useBiometrics) {
    try {
      await keytar.setPassword(KEYTAR_SERVICE, KEYTAR_ACCOUNT, key.toString('base64'));
    } catch (e) {
      console.warn('Keychain save failed, continuing without biometrics key:', e);
      s.useBiometrics = false;
      await writeSettings(s);
    }
  }

  // Encrypt existing files
  const currentPlain = existsSync(dbPath)
    ? JSON.parse(await fs.readFile(dbPath, 'utf8'))
    : structuredClone(defaultDB);
  await writeJSONFile(dbPath, currentPlain, true);

  if (existsSync(archivePath)) {
    const archPlain = JSON.parse(await fs.readFile(archivePath, 'utf8'));
    await writeJSONFile(archivePath, archPlain, true);
  }
  return { ok: true };
});

ipcMain.handle('security:disable', async () => {
  // Not exposed in UI by default; left for completeness
  let s = await readSettings();
  if (!s.encryptionEnabled) return { ok: true };
  if (!sessionKey) throw new Error('Unlock required to disable encryption');

  // Decrypt files and rewrite plaintext
  const current = await readJSONFile(dbPath, true);
  await writeJSONFile(dbPath, current, false);
  if (existsSync(archivePath)) {
    const arch = await readJSONFile(archivePath, true);
    await writeJSONFile(archivePath, arch, false);
  }
  s.encryptionEnabled = false;
  s.useBiometrics = false;
  await writeSettings(s);
  try {
    await keytar.deletePassword(KEYTAR_SERVICE, KEYTAR_ACCOUNT);
  } catch {
    console.warn('Keychain delete failed, continuing without biometrics key');
  }
  sessionKey = null;
  return { ok: true };
});

ipcMain.handle('security:unlock', async (_evt, { passcode }) => {
  console.log('=== SECURITY UNLOCK CALLED ===');
  console.log('Event data:', _evt);
  
  const s = await readSettings();
  console.log('Settings loaded:', s);
  
  if (!s.encryptionEnabled) return { ok: true }; // nothing to unlock

  console.log('Security unlock called with:', { 
    hasPasscode: !!passcode, 
    useBiometrics: s.useBiometrics, 
    biometricsAvailable: biometricsAvailable(),
    settings: s
  });

  let key = null;

  // Try biometrics first if enabled and available and no passcode provided
  if (!passcode && s.useBiometrics && biometricsAvailable()) {
    console.log('Biometrics are enabled and available, attempting biometric unlock...');
    try {
      console.log('About to prompt Touch ID...');
      await systemPreferences.promptTouchID('Unlock your tasks'); // UI gate
      console.log('Touch ID prompt completed successfully');
      
      console.log('About to access keychain...');
      const stored = await keytar.getPassword(KEYTAR_SERVICE, KEYTAR_ACCOUNT);
      console.log('Keychain access result:', { hasStored: !!stored, storedLength: stored?.length });
      
      if (stored) {
        console.log('Stored key found, converting to buffer...');
        key = Buffer.from(stored, 'base64');
        sessionKey = key;
        console.log('Unlocked successfully with biometrics, sessionKey set');
        return { ok: true, method: 'biometrics' };
      } else {
        console.log('No stored key found in keychain - returning NO_BIO_KEY without falling back');
        return { ok: false, code: 'NO_BIO_KEY', reason: 'Missing keychain entry' };
      }
    } catch (e) {
      console.log('Biometrics failed with error:', e.message);
      console.log('Error details:', e);
      console.log('Error stack:', e.stack);
      // Prompt canceled or Keychain failure; will fall back to passcode.
    }
  } else {
    console.log('Biometrics not available or not enabled:', { 
      useBiometrics: s.useBiometrics, 
      biometricsAvailable: biometricsAvailable() 
    });
  }

  // Fallback: derive from passcode (only if biometrics failed or not enabled)
  if (!passcode) {
    console.log('No passcode provided after biometric path; returning NEED_PASSCODE');
    return { ok: false, code: 'NEED_PASSCODE' };
  }

  console.log('Attempting passcode unlock...');
  key = await deriveKey(passcode, s);
  sessionKey = key;
  console.log('Unlocked successfully with passcode');
  return { ok: true, method: 'passcode' };
});

ipcMain.handle('security:lock', async () => {
  sessionKey = null;
  return { ok: true };
});

// Projects

ipcMain.handle('project:add', async (_evt, name) => {
  try {
    const s = await readSettings();
    const merged = await loadAllData(s);
    const nm = String(name || '').trim();
    if (!nm) throw new Error('Project name required');

    console.log('Project add - merged data:', {
      hasCurrent: !!merged.current,
      hasProjects: !!merged.current?.projects,
      projectsLength: merged.current?.projects?.length || 0,
      archiveProjectsLength: merged.archive?.projects?.length || 0,
    });

    // prevent dup by name (case-insensitive)
    const exists = [...(merged.current.projects || []), ...(merged.archive.projects || [])].some(
      (p) => p?.name?.toLowerCase() === nm.toLowerCase(),
    );
    if (exists) throw new Error('A project with that name already exists');

    if (!Array.isArray(merged.current.projects)) {
      console.log('Initializing projects array');
      merged.current.projects = [];
    }
    const id = `proj_${randId()}`;
    const newProject = { id, name: nm, createdAt: new Date().toISOString() };
    merged.current.projects.push(newProject);

    console.log('About to save, projects count:', merged.current.projects.length);
    await saveCurrentAndMaybeArchive(s, merged);
    console.log('Project saved successfully');

    return { id, name: nm };
  } catch (error) {
    console.error('Project add error:', error);
    throw error;
  }
});

ipcMain.handle('project:rename', async (_evt, { id, name }) => {
  const s = await readSettings();
  const merged = await loadAllData(s);
  const inCurrent = merged.current.projects.find((p) => p.id === id);
  const inArchive = merged.archive.projects?.find((p) => p.id === id);
  const target = inCurrent || inArchive;
  if (!target) throw new Error('Project not found');
  target.name = name;
  await saveCurrentAndMaybeArchive(s, merged);
  return true;
});
ipcMain.handle('project:delete', async (_evt, id) => {
  if (id === 'inbox') throw new Error('Cannot delete Inbox');
  const s = await readSettings();
  const merged = await loadAllData(s);
  merged.current.tasks.forEach((t) => {
    if (t.projectId === id) t.projectId = 'inbox';
  });
  merged.archive.tasks.forEach((t) => {
    if (t.projectId === id) t.projectId = 'inbox';
  });
  merged.current.projects = merged.current.projects.filter((p) => p.id !== id);
  merged.archive.projects = (merged.archive.projects || []).filter((p) => p.id !== id);
  await saveCurrentAndMaybeArchive(s, merged);
  return true;
});

// Tasks
ipcMain.handle('task:add', async (_evt, task) => {
  const s = await readSettings();
  const merged = await loadAllData(s);
  const id = `task_${randId()}`;
  const now = new Date().toISOString();
  const newTask = {
    id,
    title: task.title?.trim() || 'Untitled',
    description: task.description?.trim() || '',
    projectId: task.projectId || 'inbox',
    dueDate: task.dueDate || null,
    priority: clampPriority(task.priority),
    tags: Array.isArray(task.tags) ? sanitizeTags(task.tags) : [],
    completed: false,
    dateCompleted: null,
    createdAt: now,
    updatedAt: now,
  };
  merged.current.tasks.push(newTask);
  await saveCurrentAndMaybeArchive(s, merged);
  return newTask;
});

ipcMain.handle('task:update', async (_evt, partial) => {
  const s = await readSettings();
  const merged = await loadAllData(s);

  const findTask = (id) =>
    merged.current.tasks.find((t) => t.id === id) || merged.archive.tasks.find((t) => t.id === id);
  const t = findTask(partial.id);
  if (!t) throw new Error('Task not found');

  if (typeof partial.title === 'string') t.title = partial.title.trim();
  if (typeof partial.description === 'string') t.description = partial.description.trim();
  if (typeof partial.projectId === 'string') t.projectId = partial.projectId;
  if (typeof partial.dueDate !== 'undefined') t.dueDate = partial.dueDate;
  if (typeof partial.priority !== 'undefined') t.priority = clampPriority(partial.priority);
  if (Array.isArray(partial.tags)) t.tags = sanitizeTags(partial.tags);
  if (typeof partial.completed === 'boolean') {
    t.completed = partial.completed;
    t.dateCompleted = t.completed ? new Date().toISOString() : null;
  }
  t.updatedAt = new Date().toISOString();

  await saveCurrentAndMaybeArchive(s, merged);
  return t;
});

ipcMain.handle('task:delete', async (_evt, id) => {
  const s = await readSettings();
  const merged = await loadAllData(s);
  const beforeLen = merged.current.tasks.length + merged.archive.tasks.length;
  merged.current.tasks = merged.current.tasks.filter((t) => t.id !== id);
  merged.archive.tasks = merged.archive.tasks.filter((t) => t.id !== id);
  if (beforeLen === merged.current.tasks.length + merged.archive.tasks.length)
    throw new Error('Task not found');
  await saveCurrentAndMaybeArchive(s, merged);
  return true;
});

// DB: load merged view (current + archive)
ipcMain.handle('db:load', async () => {
  try {
    const s = await readSettings();
    const merged = await loadAllData(s);

    const result = {
      settings: { encryptionEnabled: s.encryptionEnabled, useBiometrics: s.useBiometrics },
      projects: merged.projects,
      tasks: merged.tasks,
    };

    console.log('db:load returning:', {
      hasSettings: !!result.settings,
      projectsCount: result.projects?.length || 0,
      tasksCount: result.tasks?.length || 0,
      projects: result.projects,
    });

    return result;
  } catch (error) {
    console.error('db:load error:', error);
    throw error;
  }
});

/* ---------- Backup / Restore ---------- */
/** Exports a single file:
 * {
 *   version:1,
 *   encryptionEnabled:boolean,
 *   settings:{kdf...},
 *   blob:{ current: <encryptedOrPlain>, archive: <encryptedOrPlain|null> }
 * }
 */
ipcMain.handle('backup:export', async () => {
  const s = await readSettings();
  const { filePath, canceled } = await dialog.showSaveDialog({
    title: 'Export Backup',
    defaultPath: join(os.homedir(), 'private-todo-offline-backup.json'),
    filters: [{ name: 'JSON', extensions: ['json'] }],
  });
  if (canceled || !filePath) return { ok: false };

  const backup = {
    version: 1,
    encryptionEnabled: s.encryptionEnabled,
    settings: s,
    blob: { current: null, archive: null },
  };
  if (s.encryptionEnabled) {
    // just copy encrypted files verbatim
    const curRaw = existsSync(dbPath) ? JSON.parse(await fs.readFile(dbPath, 'utf8')) : null;
    const arcRaw = existsSync(archivePath)
      ? JSON.parse(await fs.readFile(archivePath, 'utf8'))
      : null;
    backup.blob.current = curRaw;
    if (arcRaw) backup.blob.archive = arcRaw;
  } else {
    // copy plaintext as-is
    backup.blob.current = existsSync(dbPath)
      ? JSON.parse(await fs.readFile(dbPath, 'utf8'))
      : defaultDB;
    backup.blob.archive = existsSync(archivePath)
      ? JSON.parse(await fs.readFile(archivePath, 'utf8'))
      : null;
  }

  await fs.writeFile(filePath, JSON.stringify(backup, null, 2), 'utf8');
  return { ok: true, filePath };
});

ipcMain.handle('backup:import', async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog({
    title: 'Restore Backup',
    properties: ['openFile'],
    filters: [{ name: 'JSON', extensions: ['json'] }],
  });
  if (canceled || !filePaths?.length) return { ok: false };

  const raw = await fs.readFile(filePaths[0], 'utf8');
  const parsed = JSON.parse(raw);

  if (!parsed || !parsed.version || !parsed.blob) throw new Error('Invalid backup file');
  const s = await readSettings();

  // If backup was encrypted but app is not (or vice versa), we still write files accordingly
  if (parsed.encryptionEnabled) {
    // Write encrypted payloads directly
    await atomicWrite(dbPath, JSON.stringify(parsed.blob.current, null, 2));
    if (parsed.blob.archive)
      await atomicWrite(archivePath, JSON.stringify(parsed.blob.archive, null, 2));
  } else {
    // Write plaintext (and if app uses encryption now, we’ll re-encrypt on write)
    await writeJSONFile(dbPath, parsed.blob.current, s.encryptionEnabled);
    if (parsed.blob.archive)
      await writeJSONFile(archivePath, parsed.blob.archive, s.encryptionEnabled);
  }

  return { ok: true };
});

/* ---------- Utils ---------- */
function randId() {
  const id = Math.random().toString(36).slice(2, 10);
  console.log('Generated ID:', id);
  return id;
}
function clampPriority(p) {
  const n = Number(p);
  return Number.isNaN(n) ? 0 : Math.max(0, Math.min(3, Math.floor(n)));
}
function sanitizeTags(tags) {
  return tags
    .map((t) => String(t).trim())
    .filter(Boolean)
    .slice(0, 20);
}
